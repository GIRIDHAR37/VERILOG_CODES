Detailed Description of the 16KB Memory Design 
1. Objective
The goal of this work was to design and simulate a 16KB memory module by splitting it into four 4KB memory blocks, ensuring efficient memory access. By dividing the larger memory into smaller blocks, we manage memory in a modular fashion, improving the structure and simulation flexibility.

2. Architecture Breakdown
Memory Structure
16KB Total Size: The memory needs to handle 16,384 (2^14) memory locations, where each location stores 8 bits (1 byte) of data.
4KB Block Division: Instead of designing the entire 16KB memory as one monolithic unit, the memory was divided into four smaller 4KB blocks (2^12 locations per block).
Addressing Mechanism
14-bit Address: The system accepts a 14-bit address for the 16KB memory. This address is used to determine both the specific block and the location within that block:
The upper 2 bits (bits 13 and 12) are used to select the block (since there are 4 blocks, we need 2 bits to distinguish between them).
The lower 12 bits (bits 11:0) represent the local address within each 4KB block (since each block has 2^12 locations).
Block Selection Logic
Based on the top 2 bits of the address, one of the four memory blocks is selected. The process is as follows:
If block_select = 00, the first 4KB block is accessed.
If block_select = 01, the second 4KB block is accessed.
Similarly, block_select = 10 and 11 access the third and fourth blocks, respectively.
Data Path
Write Operation: When writing data into the memory, the block is selected using the upper 2 bits of the address. Data is then written to the selected block at the local address specified by the lower 12 bits of the address.

Read Operation: During a read operation, the selected block provides the data from the memory location identified by the lower 12 bits. Only the selected block outputs valid data, while the others remain inactive.

3. Simulation and Verification
Tools Used
Code Editing: The Gvim text editor was used to write and modify the Verilog code.

Simulation Tool: ModelSim was used for compiling, running, and debugging the design. ModelSim provides a rich set of simulation features, including waveform generation and signal monitoring.

Testbench Approach
The memory design was tested using a Verilog testbench. This testbench provides various input stimulus (e.g., addresses, data, control signals) to the memory module, allowing us to observe its behavior.

Write and Read Test:

Data was written to the memory at different addresses corresponding to different blocks.
Subsequently, read operations were performed to ensure that the data was correctly written and retrieved from the appropriate blocks.
Waveform Analysis
The simulation generated a waveform output that was visualized in ModelSim. The waveform provided a graphical view of how the memory responded to the input signals over time. Hereâ€™s a breakdown of the key signals observed in the waveform:

Clock (clk): The clock signal oscillates, and memory operations (read/write) occur on the rising edge of the clock. The timing of the clock is critical for synchronization.

Address (addr): The 14-bit address input changes over time as the testbench applies different address values for the memory operations. The upper 2 bits of this address determine which 4KB block is accessed, while the lower 12 bits specify the location within that block.

Write Enable (we): This signal indicates whether the current operation is a write (we = 1) or a read (we = 0). When we = 1, data is written to the memory at the given address. When we = 0, data is read from the memory.

Data Input (data_in): This signal shows the 8-bit data being written to the memory during write operations.

Data Output (data_out): This signal displays the data being read from the memory during read operations. The value of data_out is determined by the address and the selected block.

Block Selection (block_select): The waveform shows which of the four 4KB blocks is selected at each point in time. The block selected corresponds to the upper 2 bits of the address.

Local Address (local_addr): This signal represents the lower 12 bits of the address, which specify the location within each 4KB block.

Waveform Interpretation
The waveform generated by ModelSim shows how the memory module behaves over time:

Write Operations: For each clock cycle where we = 1, data is written to the selected 4KB block at the address specified by local_addr.

Read Operations: During read cycles (we = 0), the data stored at the address specified by local_addr in the selected block is output through data_out.

The waveform shows successful read and write operations, with correct data being written into and retrieved from different blocks of the 16KB memory.

Summary of the Work
Memory Design: The 16KB memory was designed using four 4KB blocks, with block selection based on the upper 2 bits of the 14-bit address.

Simulation and Verification: A Verilog testbench was used to apply various write and read operations. The simulation was performed in ModelSim, and the waveform output verified that the memory design was functioning as expected.

Tools: Gvim was used for writing the code, and ModelSim was used for simulation and waveform analysis.

This approach to memory design not only simplifies the implementation but also enhances flexibility and modularity, making it easier to test and debug.